あ
■言語
	JavaScript

■テーマ

タイトル
	・JavaScriptで作るドラクエ風コマンドラインゲーム

この教材を終えたら学習者はどのような状態になっているか
	・構想から簡単な設計、実装までの流れを把握している状態
	・クラスの作り方を把握している状態
	・オブジェクトの使い方を把握している状態

誰を対象としている教材なのか
	・クラスとオブジェクトの扱い方がわからない方
	・JavaScriptの初学者
	・ドラクエ風コマンドラインゲームを作り始めたい方

どの技術を中心に教えるのか
	・クラスの設計
	・プログラム開発の流れ


■学習内容
	JavaScriptのクラス、オブジェクトについて
		クラスとは
		クラスの使い方
		クラスの設計
			イメージ図を載せる
				クラスの外から呼ばれることを意識したメソッド
				クラスの中で使うことを意識したメソッド

		クラスの継承
			複数のクラスを扱うときに効果を発揮する
			親クラスは共通点を保持する
				鈴木さんと田中さんの共通点は、
					名前を持っている
					年齢がある
					話すことができる
					歩くことができる
					寝ることができる
			子クラスは特徴を保持する
				田中さんにしかないもの
					銀のナイフを持っている
					ダンスを踊れる
					猫と会話できる
			とすると
				class Human
				{
					this.名前
					this.年齢

					話す()
					{
						// 処理
					}

					歩く(distance)
					{
						// 処理
					}

					寝る(time)
					{
						// 処理
					}
				}

				class Tanaka extends Human
				{
					this.silverKnife

					Dansing()
					{
						// 処理
					}

					TalkCat()
					{
						// 処理
					}
				}

			クラスの継承はわかりにくいと感じるひとも多いので注意して使う

		オブジェクトとは
			田中さんの分身を3人使いたいときに、
			田中クラス1、田中クラス2、田中クラス3にすると
			Dansing()も3つ書かなければいけないようになってしまいます。
			ひとつの田中クラスからオブジェクトを3つ生成する方が
			プログラムの見た目もいいです。


		オブジェクトの使い方

■対象者
	クラスやオブジェクトを
	視覚的に理解したい人
	プログラミング初学者

■目次
	0章 はじめに
		1．教材の説明
		2．開発環境

	1章 構想
		キャラクター
			味方
			敵

		画面
			パラメータビュー
			モンスタービュー
			メッセージビュー
			コマンドビュー

		戦闘
			行動の順番

	2章 設計
		自分で設計するときは、実装するまで思いつかないような項目も多々あります
		なので、完全に設計してからそのとおり実装するのが理想ですが、
		ある程度見通しがついたら、実装を進めてみるといいと思います。
	
		進行の順番

			行動の順番を決める

			画面の表示
				パラメータを表示
				はじめの味方のコマンドを表示

			ユーザのイベントを待つ
				コマンドクリック
					イベントハンドラが処理を担当する
					味方のコマンドがすべて揃う

			敵味方の行動
				味方
				敵

			倒れた味方や敵の処理
				生存フラグを落とす

			勝利や敗北の判定



		必要なもの
			クラス
				主人公クラス
				モンスタークラス
				ゲーム管理

			オブジェクト
				主人公オブジェクト
				モンスターオブジェクト
				ゲーム管理

			キャラクターの配列
				グローバル空間において

			ツール類
				キャラクター配列に関する処理
				メッセージ表示処理

	3章 実装
		概要
			1. 味方と敵のクラスつくって、配列に詰める
				コンストラクタ
				攻撃メソッド（側だけ）
				回復メソッド（側だけ）
			2. ゲーム管理クラスを作る
				ゲームのはじまりは、このクラスではありません
				コマンドのクリックがゲームのトリガーになります
				

				行動の順番を決める
				パラメータを表示する
				敵の画像を表示する
				はじめのメッセージを表示する
				



		クラス
			主人公クラス
			モンスタークラス
			ゲーム管理

		オブジェクト
			主人公オブジェクト
			モンスターオブジェクト
			ゲーム管理

		キャラクターの配列
			グローバル空間において

		ツール類
			キャラクター配列に関する処理
			メッセージ表示処理








■目次の詳細

	0章 はじめに
		1．教材の全体像や概要の説明
		2．環境構築
		3．テーブル設計やURL設計など教材で作成するプロダクトの設計
		4. エラーが出たときの心得
	
	1章 構想
		主人公
			パラメータ

		モンスター
			パラメータ

		画面
			絵からはじめる
			
			パラメータビュー
				主人公の主要なパラメータを表示する
				モンスターのパラメータは表示しない

			モンスタービュー
				主人公の絵は表示しない
				モンスターの絵は表示しない

			メッセージビュー
				上にスクロール
				下にスクロール

			コマンドビュー
				コマンド選択

		機能
			コマンド入力機能
				ユーザがコマンド入力できる

			バトル機能
				敵味方がひとりずつ、攻撃や回復などを行う

			パラメータ表示機能
				味方のパラメータの更新

			メッセージ表示機能
				攻撃を受けたときや回復したとき、全滅したときなどにメッセージを表示する機能

		戦闘
			行動の順番
				素早さ順
			モンスターは動かない
			主人公の攻撃はメッセージのみで表現する

	2章 設計
		なにをどうすれば？
			構想はできました
			はじめのうちは、この段階でつまづいて、諦めてしまうことが多いです
			実装前に設計を完璧にすることは難しい
			実装してみると、あれここだめじゃん直さなきゃとかいうことは、よくあります
			この教材も当初の設計通りには実装できず、
			設計通りできないから実装を直す、設計を直す、実装を直すというようにして
			少しずつ出来上がりました。
			たとえば、はじめは生存フラグというものはありませんでした
			HPが0になったら生存していないと判定すればいいかと思っていましたが
			うまくいかなったから、生存フラグを追加した


			画面毎に考える

			誰がやるか
				処理を省略することはできない
					結局、誰か（関数）がやらなければいけない
				やるべきことが洗い出せたら、あとは作業分担


		ゲームの順番を考える
			画面の表示
				画面を表示するために
					オブジェクトが必要
					CSSが必要
					
			行動の順番を決める

			味方1人のコマンドを表示する

			コマンド入力（クリックイベント）待ち状態
				味方のコマンド選択（攻撃か回復かを選択できる）
					マウス入力
					イベントと呼ぶ
					イベントが発生したときに呼ばれるメソッドを考える
						→コマンドのロジックはなかなか難しい
				コマンドは、味方クラスのプロパティに保存しておかないといけない
			
			味方と敵の行動
			
			勝ち負けの判定を行う
				味方が全滅したらゲームオーバー
				敵を全滅させたら、主人公の勝利
			
			味方1人のコマンドを表示する
			以下、勝ち負け決まるまでループ

		画面を考える
			プログラム内部と画面の関係を図示する
				表示             [プログラム] → [画面]
				クリックイベント [プログラム] ← [画面]

			パラメータビュー
				[プログラム] → [画面]

				主人公の主要なパラメータを表示する
				モンスターのパラメータは表示しない

			モンスタービュー
				[プログラム] → [画面]

				主人公の絵は表示しない
				モンスターの絵は表示しない

			メッセージビュー
				[プログラム] → [画面]

				攻撃したとき、回復したとき、全滅したとき、勝ったとき負けたとき、
				コマンド選択の結果など、色んな所から呼ばれるだろう
				クラスのstaticとしてもいい
				グローバルに置く

					どこからでも呼び出せるようにしておく

			コマンドビュー
				[プログラム] → [画面]
				[プログラム] ← [画面]


		クラスを考える
			データと処理をまとめたもの
				なぜまとめるか？
			汎用性があるもの
			publicは小さく、privateは大きく。
			なるべくメソッドのレベルを揃えて。

		機能を考える
			図示する
				メッセージ表示
					文字列を受け取って、メッセージビューに表示
				
				パラメータ表示
					文字列を受け取って、パラメータビューに表示
				
				バトル
					敵か味方の行動
						倒れたら、配列を空にする
						勝敗の判定
							味方の全滅、または、敵の全滅でゲーム終了
					敵と味方の全員の行動終わりなら、コマンドの1へ
				
				コマンド
					1 入力待ち
					2 ユーザがコマンド選択
					3 選択されたコマンドの評価
						味方Aのコマンド終了してない場合
							新しいコマンドを表示して1へ
						味方Aのコマンド終了した場合
							味方全員がコマンド選択終わってない場合
								次の味方にチェンジして1へ
							味方全員がコマンド選択終わった場合
								バトルへ


		必要なもの
			クラス
				主人公クラス★★★
					名前
					HP
					素早さ
					攻撃力
					薬草の数
					薬草の回復力

				モンスタークラス★★★
					名前
					HP
					素早さ
					攻撃力

				ゲーム管理クラス★★★

				コマンドクラス★★★

			オブジェクト
				主人公オブジェクト
				モンスターオブジェクト
				ゲーム管理オブジェクト
				コマンドオブジェクト

			キャラクター配列
				複数の味方やたくさんのモンスターがでてきたときに対応するため
				配列にしておけば、素早さでソートして、
				要素数0から配列の長さまでforループで回せばいいと想像できる


		クラスのつくりどころ
			・メソッド間でデータを共有したい
				グローバルな関数でもできるけど、規模が大きくなってくると、わかりにくくなってきます！
				

			メッセージクラスは必要？
				メッセージクラスは今回は作りません！






		依存関係
			とても大切なところ。
			家で言ったら柱の組み方？みたいなもので
			きちんと作らないと、修正が難しくなる可能性がある
			逆にきちんと作っておけば、ソースコードを整理したり
			機能を追加することが比較的容易になります

				ゲーム管理オブジェクト
					行動の順番を決めるメソッド     ①
					ゲーム開始メソッド             ②
						無限ループ
							各キャラクターの行動

				キャラクター配列
					主人公オブジェクト
						コマンド選択メソッド       ③
						攻撃メソッド
						回復メソッド
					モンスターオブジェクト
						攻撃メソッド               ③




	3章 実装	
		実装の準備
		実装
			クラスをつくる
				主人公クラス
				ドラゴンクラス
				ガーゴイルクラス

			継承をつかう

			配列を作る
				オブジェクトを格納する

			ゲームクラスを作る
				メソッド
					start()
			ゲームオブジェクトを作る


			味方や敵のパラメータの変更方法
				

			味方や敵の追加方法
				

	4章 エラー処理
		
		想定外の動作に対応する
			防御的プログラミング




■内容





	環境編
		JavaScriptのクラスは、IE11で使える？


	設計編
		章 機能を決める

		章 流れを考える
			日本語で流れを書く
				実装できそうな段階まで詳細化していく
				（詳細化するときに難しいのは、
				プログラムはどんなことができてどんなことができないのかがわからないと、
				詳細化するのが難しいことです）

		章 データ構造を決める



	実装編
		章 実装


		クラスを図で表す






